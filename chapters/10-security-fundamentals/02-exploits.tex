\section{Bugs, vulnerabilities and exploits}

In cybersecurity, bugs, vulnerabilities, and exploits are interconnected
concepts that form a chain of risk. A \textbf{bug} is a flaw or error in a
software program's code, often unintentional, that causes unexpected behaviour.
When a bug creates a security weakness, it becomes a vulnerability, a point
where the system is susceptible to unauthorized access, data breaches, or other
malicious activities. An exploit is a malicious piece of code or technique
designed to take advantage of a vulnerability, allowing attackers to compromise
a system, steal data, or disrupt operations. Essentially, bugs can lead to
vulnerabilities, which, if unpatched, can be targeted by exploits, highlighting
the critical need for timely software updates and robust security practices.

In this section, we will discuss some of the more common types of
vulnerabilities. Although in practice you will be faced with far more complex
instances, these classes of vulnerabilities are fundamental to understanding
the evolution of mitigation techniques and what determined attackers to develop
more sophisticated malware.

\subsubsection{Stack overflow}

This type of vulnerability takes advantage of how function-local buffers are
being stored in memory, as well as developer negligence when initializing said
buffers from a potentially unbounded source of data. But first things first:

On x86 architectures, function calls are performed via the
\href{https://www.felixcloutier.com/x86/call}{CALL} instruction. This instruction
diverts the execution flow to a separate region in memory where the invoked
function resides. However, the CPU must somehow remember where to return to
after exiting the invoked function. For this purpose, the \texttt{CALL}
instruction automatically pushes the address of the following instruction
onto the stack. In a similar fashion, the invoked function will always retrieve
this value and transfer program control back to the calling function via the
\href{https://www.felixcloutier.com/x86/ret}{RET} instruction.

Herein lies the problem. By convention, the compiled programs utilize the very
same stack that is used by the \texttt{CALL} and \texttt{RET} instructions to
also store ephemeral data (i.e., function-local variables that are not
\texttt{static} in C, or function arguments depending on the
\href{https://wiki.osdev.org/Calling_Conventions}{calling convention}). On
32-bit x86 processors, Linux uses the \textbf{System V i386} calling convention.
This convention states that all function arguments should be pushed onto the
stack (from last to first) before performing the actual \texttt{CALL}.

After control is ceded to the invoked function, that function can allocate space
on the stack for local variables, be they of native types such as \texttt{int},
\texttt{float}, etc., data structures, or arrays. The only condition is that
the \textbf{ESP} register be restored to its initial value by the time the
\texttt{RET} instruction is reached. Otherwise, an incorrect return address may
be loaded in the \textbf{EIP} instruction pointer register. At first sight this
may seem like a potential risk however, the compiler (e.g., \textbf{gcc}) is the
one that automatically handles this task. So a developer cannot
\textit{unintentionally} override the correct management of the stack space
allocation that the compiler is supposed to guarantee.

\begin{wrapfigure}{l}{0.6 \textwidth}
    \centering
    \includegraphics[width=0.55 \textwidth,keepaspectratio]{figures/buffer\_overflow.pdf}
    \caption{State of the program stack when performing a function call.
             Argument cleanup falls under the purview of the caller and is not
             part of the invoked function's call frame.}
    \label{fig:call-stack}
\end{wrapfigure}

Instead, the problem occurs when the developer attempts to initialize the
function-local variables without regard for buffer boundaries. Take for example
the \href{https://www.man7.org/linux/man-pages/man3/gets.3.html}{gets()}
function from the \texttt{libc} standard library. As stated in the documentation,
this function reads a line from standard input (generally this refers to
keyboard input) until either a newline (i.e., \texttt{'\textbackslash n'})
character or a NULL string terminator (i.e., \texttt{'\textbackslash 0'}) is
encountered. Until this happens, all data that is consumed from the standard
input is stored in memory, at a user-specified address. If the developer
allocates a 100-byte buffer for example, and then proceeds to read an
\textit{unknown} amount of data into it, one should not be surprised when that
data overruns the boundaries of the character buffer and starts corrupting other
local variables and eventually, even the \textbf{return value} that was
previously stored on the stack.

Because of this, the \texttt{gets()} function has been deprecated. This means
that its use is \textit{discouraged} in favour of alternatives such as
\href{https://www.man7.org/linux/man-pages/man3/getline.3.html}{getline()}
that require a buffer size argument, to know when to stop reading data. In
practice however, \texttt{gets()} is still available in the standard library.
The reason for this is to avoid breaking backwards compatibility with older
software. Drastic, behaviour-altering changes are made to \texttt{libc} only
when a bug is identified within the library itself. However, the behaviour of
\texttt{gets()} is not incorrect.

\subsubsection{Heap overflow}

Before proceeding to this type of vulnerability, we first need to shed some
light on the finer aspects of the
\href{https://olehslabak.medium.com/linux-for-dev-4-6f89616442b7}{anatomy of a
program in memory}. First, we need to clarify that each executable is comprised
of multiple \textbf{segments} of data. Collectively, these are organized based
on the Executable Link Format (ELF). This format allows embedding non-essential
information alongside the actual executable code and program data.

\begin{lstlisting}[style=bashstyle]
$ file /bin/ls
    /bin/ls: ELF 64-bit LSB pie executable, x86-64, ...
    BuildID[sha1]=d1f6561268de19201ceee260d3a4f6662e1e70dd
\end{lstlisting}

In this example, we notice that the \texttt{file} tool is able to extract a
\textbf{build ID} from one of the core tools that comes pre-installed on any
Linux distribution. This ID is used to retrieve debug information from a
remote server if the application ever needs to be debugged. However, this
build ID is never actually loaded into main memory (i.e., RAM) by the operating
system when we execute \texttt{ls}. Instead, the operating system selectively
loads segments of the larger ELF file and sets \textbf{r}ead, \textbf{w}rite
and e\textbf{x}ecute permissions on those ranges of memory, according to the
specifications of the user (or rather, the compiler).

When writing a program, the user may declare certain global variables as being
\textit{constant} and initailizing them with fixed values. The compiler will
know to collect these variables and place them within the same \textbf{.rodata}
section that will be loaded with read-only permissions (\textbf{r--}). These
permissions are set by the operating system as per the specifications of the
compiler and are enforced at runtime by the CPU itself. Similarly, global data
that is initialized but does not have the \texttt{const} qualifier will be
placed in the \texttt{rw-} section \textbf{.data}. The generated executable code
will be placed in the \texttt{r-x} section \textbf{.text}, noting that the
program is not allowed to overwrite its own code during execution.

Try opening a terminal and inspecting the memory layout of your shell process.
In the following snippet, \texttt{\$\$} will be substituted by \texttt{zsh} or
\textbf{bash} with the Process ID (PID) of your current process (i.e., the shell
itself).

\begin{lstlisting}[style=bashstyle]
$ pmap $$
    00005556850ed000     64K r---- zsh
    00005556850fd000    724K r-x-- zsh
    00005556851b2000    108K r---- zsh
    00005556851cd000      8K r---- zsh
    00005556851cf000     24K rw--- zsh
    00005556a267d000   4024K rw---   [ anon ]
    . . .
    00007fff3028e000    276K rw---   [ stack ]
\end{lstlisting}

Observe how sections of the base binary (i.e., \texttt{zsh} in this case) are
loaded with different sets of permissions. Aside from these and other libraries
whose backing file name is known, we also have a section marked
\texttt{[ stack ]}. Its meaning should be immediately obvious at this point.
However, there is yet another section of considerable size (approx. 4MB) that
is not backed by any file, but instead is \textbf{anonymous}.

That section is the \textbf{heap}. Although the stack can be used for small
memory allocations, it can only grow up to a certain point. This limit is
enforced by the operating system and was set in order to avoid memory
exhaustion that may occur with infinite recursion bugs. As you remember, the
\texttt{CALL} instruction will utilize a minimum of 4 or 8 bytes per function
invocation, for 32-bit and 64-bit processors respectively. If a program bug
leads to a recursive function calling itself ad infinitum, the system will
eventually run out of memory. Because of this, the operating system will refuse
to allocate additional stack space once the limit is reached and the process
will be terminated.

\begin{lstlisting}[style=bashstyle]
# stack size limit per process in KB
$ ulimit -s
    8192
\end{lstlisting}

Nonetheless, modern applications need more than 8MB of memory to function. As
a result, a separate memory region called the heap was created in order to
accommodate arbitrary \textit{dynamic allocations} of memory at runtime. Note
however that the heap is not directly managed by the developer. Instead,
memory allocations and deallocations are performed via
\href{https://man7.org/linux/man-pages/man3/malloc.3.html}{malloc() and free()}
respectively. These functions are interfaces with the memory allocator of the
standard library. This allocator is responsible for efficiently assigning
memory buffers according to the user's demand and also request additional space
from the operating system when the resources allocated to the process are
being exhausted.

Observe in the previous \texttt{pmap} output that the heap is universally
accessible. Meaning that an attacker that can perform arbitrary memory accesses
on the heap can both read data stored in variables that would normally be
outside the scope of the function he compromised, and overwrite said data in
order to change the behaviour of the program without corrupting the stack. This
is known as a Data-Oriented Attack \cite{cheng2019exploitation}.

Another less obvious problem is that the heap is an excellent staging ground
for the attacker's next steps in completely compromising the program. Having
write permissions for any buffer on the heap, the attacker can first load an
arbitrary program in non-executable memory, and then utilize the stack overflow
technique described in the previous section to chain a
\href{https://man7.org/linux/man-pages/man2/mprotect.2.html}{mprotect()} call
that grants the heap executable privileges, followed by another arbitrary jump
to the attacker's code.

